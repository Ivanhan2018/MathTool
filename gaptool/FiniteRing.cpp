//#include"IRing.h"
#include"DecompositionRing.h"
#include"Rn.h"

#ifndef Rn_H
int g_M2Add[2][2]={
	 {0,1},
	 {1,0}
};

int g_M2Mul[2][2]={
	 {0,0},
	 {0,0}
};

int g_F2Add[2][2]={
	 {0,1},
	 {1,0}
};
int g_F2Mul[2][2]={
	 {0,0},
	 {0,1}
};

int g_M3Add[3][3]={
	 {0,1,2},
	 {1,2,0},
	 {2,0,1}
};
int g_M3Mul[3][3]={
	 {0,0,0},
	 {0,0,0},
	 {0,0,0}
};

int g_F3Add[3][3]={
	 {0,1,2},
	 {1,2,0},
	 {2,0,1}
};

int g_F3Mul[3][3]={
	 {0,0,0},
	 {0,1,2},
	 {0,2,1}
};

int g_F3M2Add[6][6]={
	{0,1,2,3,4,5},
	{1,0,3,2,5,4},
	{2,3,4,5,0,1},
	{3,2,5,4,1,0},
	{4,5,0,1,2,3},
	{5,4,1,0,3,2},
};
int g_F3M2Mul[6][6]={
	{0,0,0,0,0,0},
	{0,0,0,0,0,0},
	{0,0,2,2,4,4},
	{0,0,2,2,4,4},
	{0,0,4,4,2,2},
	{0,0,4,4,2,2},
};

// 环R8_3的结构不变量n0,bA,bO,n1,n2,n4,n5,n6,n7,n8=8,1,1,4,2,1,3,20,3,8,[ 1, 2, 4, 8 ],[ 1, 2, 4, 4, 8, 8, 8, 8 ]
// R8_3:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,1,2,4],8,1,1,4,2,1,3,20,3,8,[1,1,2,4],[[2,8,4],[4,4,4],[4,8,8],[8,2,4],[8,4,8],[8,8,16]]
int g_Z8Mul[8][8]={
	{0,0,0,0,0,0,0,0},
	{0,1,2,3,4,5,6,7},
	{0,2,4,6,0,2,4,6},
	{0,3,6,1,4,7,2,5},
	{0,4,0,4,0,4,0,4},
	{0,5,2,7,4,1,6,3},
	{0,6,4,2,0,6,4,2},
	{0,7,6,5,4,3,2,1}
};

//C_4×C_2――>Z/4Z×F_2
//加法表数据有误
int g_Z4F2Add[8][8]={
	{0,1,2,3,4,5,6,7},
	{1,0,3,2,5,4,7,6},
	{2,3,4,5,6,7,0,1},
	{3,2,5,4,7,6,1,0},
	{4,5,6,7,2,3,0,1},
	{5,4,7,6,3,2,1,0},
	{6,7,0,1,2,3,4,5},
	{7,6,1,0,3,2,5,4},
};

// 环R8_14的结构不变量n0,bA,bO,n1,n2,n4,n5,n6,n7,n8=4,1,1,6,4,1,1,24,5,8,[ 1, 2, 2, 4, 4, 8 ],[ 1, 2, 2, 4, 4, 4, 4, 4 ]
// R8_14:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,3,4,0],4,1,1,6,4,1,1,24,5,8,[1,2,5,0],[[2,2,8],[2,4,10],[4,2,10],[4,4,12]]
int g_Z4F2Mul[8][8]={
	{0,0,0,0,0,0,0,0},
	{0,1,0,1,0,1,0,1},
	{0,0,2,2,4,4,6,6},
	{0,1,2,3,4,5,6,7},
	{0,0,4,4,0,0,4,4},
	{0,1,4,5,0,1,4,5},
	{0,0,6,6,4,4,2,2},
	{0,1,6,7,4,5,2,3},
};

//R8_52:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,7,0,0],2,1,1,1,2,0,0,15,0,8,[1,1,0,6],[[2,2,49]]
int g_F8Add[8][8]={
	{0,   1,   2,   3,   4,   5,   6,   7},  
	{1,   0,   4,   7,   2,   6,   5,   3},  
	{2,   4,   0,   5,   1,   3,   7,   6},  
	{3,   7,   5,   0,   6,   2,   4,   1},  
	{4,   2,   1,   6,   0,   7,   3,   5},  
	{5,   6,   3,   2,   7,   0,   1,   4},  
	{6,   5,   7,   4,   3,   1,   0,   2},  
	{7,   3,   6,   1,   5,   4,   2,   0}
};

int g_F8Mul[8][8]={ 
	{0,   0,   0,   0,   0,   0,   0,   0},  
	{0,   1,   2,   3,   4,   5,   6,   7}, 
	{0,   2,   3,   4,   5,   6,   7,   1},  
	{0,   3,   4,   5,   6,   7,   1,   2},  
	{0,   4,   5,   6,   7,   1,   2,   3},  
	{0,   5,   6,   7,   1,   2,   3,   4},  
	{0,   6,   7,   1,   2,   3,   4,   5},  
	{0,   7,   1,   2,   3,   4,   5,   6}
};
#endif

int g_M3M2_M6Add[6][6]={
	 {0,1,2,3,4,5},
	 {1,2,3,4,5,0},
	 {2,3,4,5,0,1},
	 {3,4,5,0,1,2},
	 {4,5,0,1,2,3},
	 {5,0,1,2,3,4}
}; 

int g_M3M2_M6Mul[6][6]={
	 {0,0,0,0,0,0},
	 {0,0,0,0,0,0},
	 {0,0,0,0,0,0},
	 {0,0,0,0,0,0},
	 {0,0,0,0,0,0},
	 {0,0,0,0,0,0}
};

//R6_2
int g_F3M2_R2Add[6][6]={
	 {0,1,2,3,4,5},
	 {1,2,3,4,5,0},
	 {2,3,4,5,0,1},
	 {3,4,5,0,1,2},
	 {4,5,0,1,2,3},
	 {5,0,1,2,3,4}
};

int g_F3M2_R2Mul[6][6]={
	 {0,0,0,0,0,0},
	 {0,2,4,0,2,4},
	 {0,4,2,0,4,2},
	 {0,0,0,0,0,0},
	 {0,2,4,0,2,4},
	 {0,4,2,0,4,2}
};

//R6_4
int g_F3F2_Z6Add[6][6]={
	 {0,1,2,3,4,5},
	 {1,2,3,4,5,0},
	 {2,3,4,5,0,1},
	 {3,4,5,0,1,2},
	 {4,5,0,1,2,3},
	 {5,0,1,2,3,4}
};

int g_F3F2_Z6Mul[6][6]={
	 {0,0,0,0,0,0},
	 {0,1,2,3,4,5},
	 {0,2,4,0,2,4},
	 {0,3,0,3,0,3},
	 {0,4,2,0,4,2},
	 {0,5,4,3,2,1}
};

//R6_4
int g_F3F2Add[6][6]={
	{0,1,2,3,4,5},
	{1,0,3,2,5,4},
	{2,3,4,5,0,1},
	{3,2,5,4,1,0},
	{4,5,0,1,2,3},
	{5,4,1,0,3,2},
};

int g_F3F2Mul[6][6]={
	{0,0,0,0,0,0},
	{0,1,0,1,0,1},
	{0,0,2,2,4,4},
	{0,1,2,3,4,5},
	{0,0,4,4,2,2},
	{0,1,4,5,2,3},
};

int g_C8Mul[8][8]={
	{0, 1, 2, 3, 4, 5, 6, 7},
	{1, 0, 3, 2, 5, 4, 7, 6},
	{2, 3, 1, 0, 6, 7, 5, 4},
	{3, 2, 0, 1, 7, 6, 4, 5},
	{4, 5, 6, 7, 2, 3, 1, 0},
	{5, 4, 7, 6, 3, 2, 0, 1},
	{6, 7, 5, 4, 1, 0, 3, 2},
	{7, 6, 4, 5, 0, 1, 2, 3}
};

int g_C8Mul_2[8][8]={
	{0,1,2,3,4,5,6,7},
	{1,2,3,4,5,6,7,0},
	{2,3,4,5,6,7,0,1},
	{3,4,5,6,7,0,1,2},
	{4,5,6,7,0,1,2,3},
	{5,6,7,0,1,2,3,4},
	{6,7,0,1,2,3,4,5},
	{7,0,1,2,3,4,5,6}
};

//int* g_C8Add=&g_C8Mul[0][0];//Error,与乘法表g_Z8Mul不相容
int* g_C8Add=&g_C8Mul_2[0][0];

// 环R8_2的结构不变量n0,bA,bO,n1,n2,n4,n5,n6,n7,n8=8,1,0,8,1,3,3,32,7,8,[ 1, 2, 4, 8 ],[ 1, 2, 4, 4, 8, 8, 8, 8 ]
// R8_2:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,1,2,4],8,1,0,8,1,3,3,32,7,8,[1,1,2,4],[[4,8,8],[8,4,8],[8,8,16]]
int g_C8R2Mul[8][8]={
	{0,0,0,0,0,0,0,0},
	{0,2,4,6,0,2,4,6},
	{0,4,0,4,0,4,0,4},
	{0,6,4,2,0,6,4,2},
	{0,0,0,0,0,0,0,0},
	{0,2,4,6,0,2,4,6},
	{0,4,0,4,0,4,0,4},
	{0,6,4,2,0,6,4,2}
};

// 环R8_4的结构不变量n0,bA,bO,n1,n2,n4,n5,n6,n7,n8=8,1,0,8,1,3,7,48,7,8,[ 1, 2, 4, 8 ],[ 1, 2, 4, 4, 8, 8, 8, 8 ]
// R8_4:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,1,2,4],8,1,0,8,1,3,7,48,7,8,[1,1,2,4],[[8,8,16]]
int g_C8R4Mul[8][8]={
	{0,0,0,0,0,0,0,0},
	{0,4,0,4,0,4,0,4},
	{0,0,0,0,0,0,0,0},
	{0,4,0,4,0,4,0,4},
	{0,0,0,0,0,0,0,0},
	{0,4,0,4,0,4,0,4},
	{0,0,0,0,0,0,0,0},
	{0,4,0,4,0,4,0,4},
};


int g_C2C4Mul[8][8]={
	{0, 1, 2, 3, 4, 5, 6, 7},
	{1, 0, 3, 2, 5, 4, 7, 6},
	{2, 3, 0, 1, 6, 7, 4, 5},
	{3, 2, 1, 0, 7, 6, 5, 4},
	{4, 5, 6, 7, 1, 0, 3, 2},
	{5, 4, 7, 6, 0, 1, 2, 3},
	{6, 7, 4, 5, 3, 2, 1, 0},
	{7, 6, 5, 4, 2, 3, 0, 1}
};

int g_C2C4Mul_2[8][8]={
	{0,1,2,3,4,5,6,7},
	{1,4,7,2,5,0,3,6},
	{2,7,4,1,6,3,0,5},
	{3,2,1,0,7,6,5,4},
	{4,5,6,7,0,1,2,3},
	{5,0,3,6,1,4,7,2},
	{6,3,0,5,2,7,4,1},
	{7,6,5,4,3,2,1,0}
};

//int* g_C2C4Add=&g_C2C4Mul[0][0];//Error,与乘法表g_Z4F2Mul不相容
int* g_C2C4Add=&g_C2C4Mul_2[0][0];


// C_2×C_2×C_2――>邢丹丹论文中的8阶环R_1
//加法表数据有误
int g_R8_C2C2C2_28_R1_Add[8][8]={
	{0,1,2,3,4,5,6,7},
	{1,0,3,2,5,4,7,6},
	{2,3,0,1,6,7,4,5},
	{3,2,0,1,7,6,5,4},
	{4,5,6,7,0,1,2,3},
	{5,4,7,6,1,0,3,2},
	{6,7,4,5,2,3,0,1},
	{7,6,5,4,3,2,1,0}
};

// 乘法表数据有误
int g_R8_C2C2C2_28_1Mul[8][8]={
	{0,0,0,0,0,0,0,0},
	{0,1,0,0,0,1,0,1},
	{0,0,2,2,0,0,2,2},
	{0,0,2,3,0,1,2,3},
	{0,0,0,0,4,4,4,4},
	{0,1,0,1,4,5,4,5},
	{0,0,2,2,4,4,6,6},
	{0,1,2,3,4,5,6,7}
};

//R={{{a,0,0},{b,a,0},{c,0,a}}|a,b,c∈Z/2Z}<=M_3(Z/2Z)是8阶交换幺环
//环R8_45的结构不变量n0,bA,bO,n1,n2,n4,n5,n6,n7,n8=2,1,1,4,2,3,3,24,3,8,[ 1, 2, 2, 2, 4, 8 ],[ 1, 2, 2, 2, 2, 4, 4, 4 ]
//R8_45:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,7,0,0],2,1,1,4,2,3,3,24,3,8,[1,4,3,0],[[2,2,40]]
int g_R8_C2C2C2_28_R1_Mul[8][8]={
	 {0,0,0,0,0,0,0,0},
	 {0,1,2,3,4,5,6,7},
	 {0,2,0,2,0,2,0,2},
	 {0,3,2,1,4,7,6,5},
	 {0,4,0,4,0,4,0,4},
	 {0,5,2,7,4,1,6,3},
	 {0,6,0,6,0,6,0,6},
	 {0,7,2,5,4,3,6,1}
};

int g_R8_C2C2C2_28_2Mul[8][8]={
	{0,0,0,0,0,0,0,0},
	{0,1,2,3,4,5,6,7},
	{0,2,0,2,0,2,0,2},
	{0,3,2,1,4,7,6,5},
	{0,4,0,4,0,4,0,4},
	{0,5,2,7,4,1,6,5},
	{0,6,0,6,0,6,0,6},
	{0,7,2,5,4,5,6,1}
};

int g_C2C2C2Mul[8][8]={
	{0, 1, 2, 3, 4, 5, 6, 7},
	{1, 0, 3, 2, 5, 4, 7, 6},
	{2, 3, 0, 1, 6, 7, 4, 5},
	{3, 2, 1, 0, 7, 6, 5, 4},
	{4, 5, 6, 7, 0, 1, 2, 3},
	{5, 4, 7, 6, 1, 0, 3, 2},
	{6, 7, 4, 5, 2, 3, 0, 1},
	{7, 6, 5, 4, 3, 2, 1, 0}
};
int* g_C2C2C2Add=&g_C2C2C2Mul[0][0];

// C_2×C_2×C_2――>邢丹丹论文中的8阶环R_3
// 乘法表数据有误
int g_R8_C2C2C2_28_R3_Mul[8][8]={
	 {0,0,0,0,0,0,0,0},
	 {0,1,2,3,4,5,6,7},
	 {0,2,0,2,0,2,0,2},
	 {0,3,2,1,4,7,6,5},
	 {0,4,0,4,3,7,3,7},//这一行后4个元素变了
	 {0,5,2,7,7,2,5,0},//这一行后4个元素变了
	 {0,6,0,6,3,5,3,5},//这一行后4个元素变了
	 {0,7,2,5,7,0,5,2}//这一行后4个元素变了
};

// C_2×C_2×C_2――>邢丹丹论文中的8阶环R_2
// 乘法表数据有误
int g_R8_C2C2C2_28_R2_Mul[8][8]={
	 {0,0,0,0,0,0,0,0},
	 {0,1,2,3,4,5,6,7},
	 {0,2,0,2,0,2,0,2},
	 {0,3,2,1,4,7,6,5},
	 {0,4,0,4,2,6,2,6},//这一行后4个元素变了
	 {0,5,2,7,6,3,4,1},//这一行后4个元素变了
	 {0,6,0,6,2,4,2,4},//这一行后4个元素变了
	 {0,7,2,5,4,1,4,3}//这一行后3个元素变了
};

//环R8_49的结构不变量n0,bA,bO,n1,n2,n4,n5,n6,n7,n8=2,0,1,6,6,1,1,26,5,2,[ 1, 2, 4, 4, 8 ],[ 1, 2, 2, 2, 2, 2, 2, 4 ]
//R8_49:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,7,0,0],2,0,1,6,6,1,1,26,5,2,[1,6,1,0],[[2,2,38]]
int g_R8_C2C2C2_28_3Mul[8][8]={
	{0,0,0,0,0,0,0,0},
	{0,1,0,1,4,5,4,5},
	{0,0,2,2,0,0,2,2},
	{0,1,2,3,4,5,6,7},
	{0,0,4,4,0,0,4,4},
	{0,1,4,5,4,5,0,1},
	{0,0,6,6,0,0,6,6},
	{0,1,6,7,4,5,2,3},
};

//C_2×C_2×C_2――>F_4×F_2
//R8_51:N0n0bAbOn1n2n4n5n6n7n8S1N2=[1,7,0,0],2,1,1,5,4,0,0,21,4,8,[1,3,2,2],[[2,2,43]]
int g_F4F2Add[8][8]={
	{0,1,2,3,4,5,6,7},
	{1,0,3,2,5,4,7,6},
	{2,3,0,1,6,7,4,5},
	{3,2,1,0,7,6,5,4},
	{4,5,6,7,0,1,2,3},
	{5,4,7,6,1,0,3,2},
	{6,7,4,5,2,3,0,1},
	{7,6,5,4,3,2,1,0},
};

int g_F4F2Mul[8][8]={
	{0,0,0,0,0,0,0,0},
	{0,1,0,1,0,1,0,1},
	{0,0,2,2,4,4,6,6},
	{0,1,2,3,4,5,6,7},
	{0,0,4,4,6,6,2,2},
	{0,1,4,5,6,7,2,3},
	{0,0,6,6,2,2,4,4},
	{0,1,6,7,2,3,4,5},
};


// 直接从凯莱表构造一个有限环
struct FiniteRing:public IRing
{
public:
	//  静态函数  
public:
	// 实现抽象基类的方法
	virtual void printTable();
	virtual int add(int a,int b);
	virtual int mul(int a,int b);
	virtual int size(); 
	// 构造函数
	FiniteRing(int n,int* a,int* m,int delt);  
	// 成员变量  
	int m_n; 
	int* m_Add;
	int* m_Mul; 
	int m_delt; 
};

void FiniteRing::printTable()
{
	int ID=IdRing(this);
	string str=calcRingInvariant(this);
	printf("R%d_%d:N0n0bAbOn1n2n4n5n6n7n8S1N2=%s\n",size(),ID,str.c_str());
	//printRing(this);	
}

int FiniteRing::add(int a,int b)
{
	int c=*(m_Add+a*m_n+b);
	return c-m_delt;
}

int FiniteRing::mul(int a,int b)
{
	int c=*(m_Mul+a*m_n+b);
	return c-m_delt;
}

int FiniteRing::size()
{
	return m_n;
}

FiniteRing::FiniteRing(int n,int* a,int* m,int delt)
{
	m_n=n;
	m_Add=a;
    m_Mul=m;
    m_delt=delt;	
}

IRing* newR2(int i)
{
	if(i==1)
	{
		ZmodnZ* r=new ZmodnZ(2,4);
		return r;
	}
	if(i==2)
	{
		ZmodnZ* r=new ZmodnZ(1,2);
		return r;
	}
	return NULL;
}

IRing* newR8(int i)
{
	if(i==1)
	{
		ZmodnZ* r=new ZmodnZ(8,64);
		return r;
	}
	if(i==2)
	{
		ZmodnZ* r=new ZmodnZ(2,16);
		return r;
	}	
	if(i==3)
	{
		ZmodnZ* r=new ZmodnZ(1,8);
		return r;
	}
	if(i==4)
	{
		ZmodnZ* r=new ZmodnZ(4,32);
		return r;
	}
	if(i==6)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_6Mul[0][0],0);
		return r;
	}
	if(i==8)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_8Mul[0][0],0);
		return r;
	}
	if(i==9)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_9Mul[0][0],0);
		return r;
	}
	if(i==10)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_10Mul[0][0],0);
		return r;
	}
	if(i==11)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_11Mul[0][0],0);
		return r;
	}
	if(i==12)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_12Mul[0][0],0);
		return r;
	}
	if(i==14)
	{
		FiniteRing* r=new FiniteRing(8,g_C2C4Add,&g_Z4F2Mul[0][0],0);
		return r;
	}
	if(i==15)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_15Mul[0][0],0);
		return r;
	}
	if(i==18)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_18Mul[0][0],0);
		return r;
	}
	if(i==20)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_20Mul[0][0],0);
		return r;
	}
	if(i==22)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_22Mul[0][0],0);
		return r;
	}
	if(i==23)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_23Mul[0][0],0);
		return r;
	}
	if(i==24)
	{
		FiniteRing* r=new FiniteRing(8,&g_R8_24Add[0][0],&g_R8_24Mul[0][0],0);
		return r;
	}
	if(i==31)
	{
		FiniteRing* r=new FiniteRing(8,&g_F8Add[0][0],&g_R8_31Mul[0][0],0);
		return r;
	}
	if(i==32)
	{
		FiniteRing* r=new FiniteRing(8,&g_F8Add[0][0],&g_R8_32Mul[0][0],0);
		return r;
	}
	if(i==36)
	{
		FiniteRing* r=new FiniteRing(8,&g_F8Add[0][0],&g_R8_36Mul[0][0],0);
		return r;
	}
	if(i==37)
	{
		FiniteRing* r=new FiniteRing(8,&g_F8Add[0][0],&g_R8_37Mul[0][0],0);
		return r;
	}
	if(i==39)
	{
		FiniteRing* r=new FiniteRing(8,&g_F8Add[0][0],&g_R8_39Mul[0][0],0);
		return r;
	}
	if(i==45)
	{
		FiniteRing* r=new FiniteRing(8,&g_F4F2Add[0][0],&g_R8_C2C2C2_28_2Mul[0][0],0);
		return r;
	}
	if(i==49)
	{
		FiniteRing* r=new FiniteRing(8,&g_F4F2Add[0][0],&g_R8_C2C2C2_28_3Mul[0][0],0);
		return r;
	}	
	if(i==51)
	{
		FiniteRing* r=new FiniteRing(8,&g_F4F2Add[0][0],&g_F4F2Mul[0][0],0);
		return r;
	}	
	if(i==52)
	{
		FiniteRing* r=new FiniteRing(8,&g_F8Add[0][0],&g_F8Mul[0][0],0);
		return r;
	}	
	return NULL;
}	

IRing* newR8R2(int ij)
{
	int i=(ij-1)%52+1;
	int j=(ij-1)/52+1;
    IRing* ri=newR8(i);
	if(!ri)
		return NULL;
    IRing* rj=newR2(j);
	if(!rj){
		delete ri;
		return NULL;
	}
	DecompositionRing* r= new DecompositionRing(ri,rj);
	r->m_flag=1;
	return r;
}

void test1()
{
    int *R8Add[]={&g_M2Add[0][0],&g_F2Add[0][0],&g_M3Add[0][0],&g_F3Add[0][0],&g_M3M2_M6Add[0][0],&g_F3M2_R2Add[0][0],&g_F3M2Add[0][0],&g_F3F2Add[0][0],g_C8Add,g_C8Add,g_C8Add,g_C2C4Add,&g_F4F2Add[0][0],&g_F4F2Add[0][0],&g_F4F2Add[0][0],&g_F4F2Add[0][0],&g_F8Add[0][0]};
    int *R8Mul[]={&g_M2Mul[0][0],&g_F2Mul[0][0],&g_M3Mul[0][0],&g_F3Mul[0][0],&g_M3M2_M6Mul[0][0],&g_F3M2_R2Mul[0][0],&g_F3M2Mul[0][0],&g_F3F2Mul[0][0],&g_C8R2Mul[0][0],&g_Z8Mul[0][0],&g_C8R4Mul[0][0],&g_Z4F2Mul[0][0],&g_R8_C2C2C2_28_R1_Mul[0][0],&g_R8_C2C2C2_28_2Mul[0][0],&g_R8_C2C2C2_28_3Mul[0][0],&g_F4F2Mul[0][0],&g_F8Mul[0][0]};
	int nArr[]={2,2,3,3,6,6,6,6,8,8,8,8,8,8,8,8,8};
	int nDelt[]={0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
	int nNum=sizeof(nArr)/sizeof(nArr[0]);
	for(int i=0;i<nNum;i++)
	{
		FiniteRing fr(nArr[i],R8Add[i],R8Mul[i],nDelt[i]);
		fr.printTable();
	}	
}

int main()
{
   for(int i=1;i<=104;i++)
   {
	   IRing* r=newR8R2(i);
	   if(r){
		   printf("R8R2_%d=",i);
		   r->printTable();
		   if(i==84 && i==85){
			   string I1=calcI1(r);
			   string I2=calcI2(r);   
			   printf("I1I2=%s,%s\n",I1.c_str(),I2.c_str());
		   }
		   delete r;
		   r=NULL;
	   }	   
   }
	system("pause");
	return 0;
}